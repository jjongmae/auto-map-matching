# 카메라 파라미터 최적화 알고리즘

## 개요

차선 라벨링 데이터에 맞춰 카메라 파라미터(yaw, pitch, roll, fx, fy)를 자동으로 피팅하기 위해 사용하는 최적화 알고리즘들을 정리한 문서입니다.

## SciPy Optimize 라이브러리

본 프로젝트의 최적화 모듈은 Python의 과학 계산 라이브러리인 **SciPy**의 `optimize` 패키지를 핵심 엔진으로 사용합니다.

**SciPy**는 2001년 **Travis Oliphant**, **Pearu Peterson**, **Eric Jones** 등이 주도하여 개발한 오픈 소스 라이브러리로, NumPy를 기반으로 하여 복잡한 과학 및 공학적 계산을 위한 다양한 알고리즘을 제공합니다. 전 세계의 수많은 과학자와 엔지니어들에 의해 지속적으로 발전되어 왔으며, Python 생태계에서 사실상의 표준 과학 계산 도구로 자리 잡았습니다.

**`scipy.optimize`**는 다음과 같은 강력한 기능을 제공합니다:
- **함수 최적화**: 로컬 및 글로벌 최적화 알고리즘 제공 (`minimize`, `differential_evolution` 등)
- **최소제곱 문제 해결**: 비선형 최소제곱 문제에 특화된 솔버 제공 (`least_squares`)
- **다양한 알고리즘 지원**: 구배(Gradient) 기반 방법부터 미분 불가능한 함수를 위한 방법까지 폭넓은 알고리즘 포함

이 패키지는 안정성과 성능이 검증되어 있으며, 복잡한 수치 최적화 문제를 효율적으로 해결할 수 있도록 돕습니다. 본 프로젝트에서는 이 라이브러리를 활용하여 카메라 파라미터와 재투영된 차선 사이의 오차를 최소화합니다.

---

## 현재 구현된 알고리즘 (4가지)

### 1. Powell

**방식**: 방향 탐색 (Direction Set Method)

**원리**:
- 각 파라미터 축 방향으로 순차적으로 1차원 최적화를 수행
- 한 방향으로 최적점을 찾은 후 다음 방향으로 이동
- 모든 방향을 탐색한 후, 새로운 방향 벡터를 생성하여 반복

**장점**:
- 그래디언트(기울기) 계산이 필요 없음
- 경계(bounds) 조건 지원
- 구현이 간단하고 범용적

**단점**:
- 국소 최적점(local minimum)에 빠지기 쉬움
- 파라미터 간 상관관계가 강할 때 수렴이 느림
- 고차원에서 효율이 떨어질 수 있음

**적합한 상황**:
- 파라미터 수가 적고 경계 조건이 필요할 때
- 비용 함수의 그래디언트를 계산하기 어려울 때

---

### 2. Nelder-Mead (Simplex Method)

**방식**: 심플렉스 기반 직접 탐색

**원리**:
- N차원 공간에서 (N+1)개의 꼭짓점을 가진 심플렉스(다면체)를 사용
- 심플렉스를 반사(reflection), 확장(expansion), 수축(contraction), 축소(shrink) 연산으로 변형
- 비용이 가장 높은 꼭짓점을 계속 대체하며 최적점으로 수렴

**장점**:
- 그래디언트 계산이 필요 없음
- 노이즈가 있는 비용 함수에 강건함
- 수렴이 안정적
- 저차원(10개 이하 파라미터)에서 효과적

**단점**:
- 경계 조건을 직접 지원하지 않음 (후처리로 클리핑 필요)
- 고차원에서 수렴 속도가 급격히 느려짐
- 이론적 수렴 보장이 약함

**적합한 상황**:
- 비용 함수에 노이즈가 있을 때
- 파라미터 수가 10개 이하일 때
- 그래디언트 기반 방법이 실패할 때

---

### 3. Levenberg-Marquardt (LM)

**방식**: 비선형 최소제곱 (Nonlinear Least Squares)

**원리**:
- Gauss-Newton 방법과 경사하강법의 혼합
- 야코비안(Jacobian) 행렬을 사용하여 2차 근사
- 댐핑 파라미터(λ)로 두 방법 사이를 적응적으로 전환
  - λ가 크면 → 경사하강법처럼 동작 (안정적)
  - λ가 작으면 → Gauss-Newton처럼 동작 (빠름)

**장점**:
- 비선형 최소제곱 문제에 특화
- 수렴 속도가 빠름
- 로봇 비전, 카메라 캘리브레이션의 사실상 표준
- 각 데이터 포인트의 잔차(residual)를 활용하여 효율적

**단점**:
- 비용 함수가 "잔차 제곱합" 형태여야 함
- 야코비안 계산 필요 (수치 미분 사용 시 비용 증가)
- 초기값에 민감할 수 있음
- **불연속적인(non-smooth) 비용 함수에 취약** - `min()`, `argmin()` 등 사용 시 야코비안이 부정확해짐

**적합한 상황**:
- 카메라 캘리브레이션, 포즈 추정
- 데이터 포인트별 오차를 개별적으로 계산할 수 있을 때
- **비용 함수가 파라미터에 대해 미분 가능(smooth)할 때**
- 정확도가 중요한 경우

---

### 4. Differential Evolution (DE)

**방식**: 진화 알고리즘 (Evolutionary Algorithm)

**원리**:
- 개체군(population) 기반 최적화 알고리즘
- 각 세대마다 변이(mutation), 재조합(crossover), 선택(selection) 연산 수행
  1. **변이**: 무작위로 선택된 개체들의 차이 벡터를 이용하여 돌연변이 생성
  2. **재조합**: 원래 개체와 돌연변이를 섞어 시험 벡터 생성
  3. **선택**: 시험 벡터가 더 좋은 비용을 가지면 다음 세대로 선택
- 전역 탐색(exploration)과 지역 탐색(exploitation)의 균형을 유지

**장점**:
- **글로벌 최적화**: 로컬 미니멈 탈출 능력이 뛰어남
- 그래디언트 계산이 필요 없음
- 경계 조건 완벽 지원
- **불연속적(non-smooth)이고 노이즈가 있는 함수에 강건**
- 다봉형(multimodal) 비용 함수에 효과적
- 병렬 처리 가능 (개체군을 동시에 평가)

**단점**:
- 수렴 속도가 비교적 느림 (많은 비용 함수 평가 필요)
- 파라미터 튜닝 필요 (popsize, mutation, recombination)
- 고차원 문제에서 개체군 크기가 커져야 함
- 메모리 사용량이 많음 (개체군 전체를 저장)

**적합한 상황**:
- **로컬 미니멈이 많은 복잡한 비용 함수**
- **비용 함수가 불연속적이거나 노이즈가 있을 때**
- 글로벌 최적해를 찾는 것이 중요할 때
- 다른 알고리즘이 로컬 미니멈에 갇힐 때
- 계산 시간보다 정확도가 더 중요할 때

---

## 4가지 알고리즘 비교

| 항목                 | Powell    | Nelder-Mead | LM                      | Differential Evolution    |
| -------------------- | --------- | ----------- | ----------------------- | ------------------------- |
| **방식**             | 방향 탐색 | 심플렉스    | 비선형 최소제곱         | 진화 알고리즘             |
| **그래디언트**       | 불필요    | 불필요      | 필요 (수치 미분 가능)   | 불필요                    |
| **경계 지원**        | O         | X (후처리)  | O                       | O                         |
| **노이즈 강건성**    | 보통      | 강함        | 보통                    | **매우 강함**             |
| **불연속 함수**      | 강함      | 강함        | **취약**                | **매우 강함**             |
| **글로벌 최적화**    | 약함      | 약함        | 약함                    | **매우 강함**             |
| **수렴 속도**        | 보통      | 느림        | 빠름 (smooth 함수일 때) | 느림                      |
| **정확도**           | 보통      | 보통        | 높음 (smooth 함수일 때) | **높음** (충분한 세대 시) |
| **권장 파라미터 수** | 제한 없음 | 10개 이하   | 제한 없음               | 20개 이하                 |
| **로봇 비전 사용**   | 드묾      | 가끔        | 표준 (smooth 잔차일 때) | 복잡한 문제 시            |

---

## 추가 알고리즘 (scipy.optimize에서 제공)

### 그래디언트 기반

| 알고리즘         | 설명                                | 경계 | 특징                              |
| ---------------- | ----------------------------------- | ---- | --------------------------------- |
| **CG**           | 켤레 기울기법 (Conjugate Gradient)  | X    | 대규모 문제에 효율적, 메모리 절약 |
| **BFGS**         | 준뉴턴법 (Quasi-Newton)             | X    | 헤시안 근사, 수렴 빠름            |
| **L-BFGS-B**     | 메모리 효율적 BFGS                  | O    | 대규모 문제, 경계 지원            |
| **TNC**          | 뉴턴 켤레 기울기 (Truncated Newton) | O    | 대규모 경계 문제에 적합           |
| **SLSQP**        | 순차 이차 계획법                    | O    | 등식/부등식 제약조건 지원         |
| **trust-constr** | 신뢰 영역 기반                      | O    | 복잡한 제약조건 지원              |

### 그래디언트 불필요

| 알고리즘   | 설명           | 경계 | 특징                         |
| ---------- | -------------- | ---- | ---------------------------- |
| **COBYLA** | 선형 근사 기반 | O    | 제약조건 지원, 노이즈에 강함 |

---

## 로봇 비전 분야에서 사용하는 전문 라이브러리

실제 프로덕션 환경에서는 scipy보다 전문 라이브러리를 더 많이 사용합니다.

### Ceres Solver (Google)

- **용도**: Bundle Adjustment, SLAM, 카메라 캘리브레이션
- **특징**: C++ 기반, 자동 미분, 희소 행렬 최적화
- **알고리즘**: LM, Dogleg, Trust Region
- **사용처**: Google Street View, Cartographer SLAM

### g2o (General Graph Optimization)

- **용도**: 그래프 기반 SLAM
- **특징**: 희소 행렬 특화, 포즈 그래프 최적화
- **알고리즘**: Gauss-Newton, LM
- **사용처**: ORB-SLAM, LSD-SLAM

### GTSAM (Georgia Tech Smoothing and Mapping)

- **용도**: Factor Graph 기반 추론
- **특징**: 확률적 추론, 증분 최적화 (iSAM2)
- **알고리즘**: Gauss-Newton, LM, iSAM2
- **사용처**: 자율주행, 드론 내비게이션

### OpenCV (solvePnP)

- **용도**: 카메라 포즈 추정
- **특징**: 간단한 API, 다양한 방법 지원
- **알고리즘**: EPnP, P3P, IPPE, LM refinement
- **사용처**: AR, 로봇 비전

---

## 알고리즘 선택 가이드

```
비용 함수가 smooth(미분 가능)한가?
├── 예 → 비용 함수가 "잔차 제곱합" 형태인가?
│        ├── 예 → Levenberg-Marquardt (LM) 권장
│        │        (가장 빠르고 정확)
│        │
│        └── 아니오 → 그래디언트 계산이 가능한가?
│                     ├── 예 → L-BFGS-B 권장
│                     │        (빠른 수렴, 경계 지원)
│                     │
│                     └── 아니오 → Powell 권장
│                                  (범용적, 경계 지원)
│
└── 아니오 (min, argmin 등 사용) → 로컬 미니멈이 많거나 글로벌 최적해가 중요한가?
                                   ├── 예 → Differential Evolution 권장
                                   │        (글로벌 최적화, 로컬 미니멈 탈출)
                                   │
                                   └── 아니오 → 노이즈가 많은가?
                                                ├── 예 → Nelder-Mead 권장
                                                │        (노이즈에 강건)
                                                │
                                                └── 아니오 → Powell 권장
                                                             (범용적, 경계 지원)
```

> **현재 프로젝트**: `min()` 기반 비용 함수 → non-smooth → **Differential Evolution, Powell, 또는 Nelder-Mead 권장**

---

## 현재 프로젝트에서의 적용

### 비용 함수 정의

```
비용 = 평균(각 라벨링 점에서 가장 가까운 투영 점까지의 거리)
잔차 = 각 라벨링 점에서 가장 가까운 투영 점까지의 거리 (LM용)
```

### 비용 함수의 특성

**중요**: 현재 비용 함수는 `np.min(distances, axis=1)`을 사용하여 "가장 가까운 점"을 찾습니다.
이 `min()` 연산은 **불연속점(non-smooth)**을 만듭니다:
- 파라미터가 조금 바뀌면 "가장 가까운 점"이 갑자기 다른 점으로 바뀔 수 있음
- 이 지점에서 야코비안(미분)이 불연속이 되어 LM 알고리즘의 방향 탐색이 부정확해짐
- 결과적으로 LM이 로컬 미니멈에 쉽게 갇히고 조기 종료됨

### 최적화 대상 파라미터 (5개)

| 파라미터 | 설명          | 탐색 범위 |
| -------- | ------------- | --------- |
| yaw      | 수평 회전     | ±10도     |
| pitch    | 수직 회전     | ±10도     |
| roll     | 축 회전       | ±10도     |
| fx       | 수평 초점거리 | ±20%      |
| fy       | 수직 초점거리 | ±20%      |

### 권장 사용 순서

> **주의**: 현재 프로젝트의 비용 함수는 `min()` 기반으로 불연속적이므로,
> 그래디언트 기반인 LM보다 derivative-free 방법이 더 적합합니다.

1. **Powell**: 가장 먼저 시도 (빠르고, 경계 지원, 불연속 함수에 강건)
2. **Differential Evolution**: 글로벌 최적해를 찾고 싶거나 Powell이 로컬 미니멈에 갇힐 때
3. **Nelder-Mead**: 노이즈가 의심되거나 다른 방법이 실패할 때
4. **LM**: 참고용 (이론적으로는 좋지만 현재 비용 함수와 궁합이 맞지 않음)

**알고리즘별 사용 시나리오**:
- **빠른 결과가 필요**: Powell → Nelder-Mead
- **최고 정확도가 필요**: Differential Evolution (시간이 오래 걸리지만 글로벌 최적해 보장)
- **다른 알고리즘이 실패**: Differential Evolution으로 재시도 (로컬 미니멈 탈출)

### LM이 잘 작동하지 않는 이유

```
[일반적인 카메라 캘리브레이션]
- 체커보드 코너 검출 → 대응점이 명확히 1:1 매칭됨
- 잔차 = 검출점과 투영점의 거리 → smooth 함수
- LM이 최적

[현재 프로젝트]
- 라벨링 점 → 가장 가까운 투영 차선점 매칭 (min 연산)
- 잔차 = 라벨링 점에서 가장 가까운 점까지의 거리 → non-smooth 함수
- LM의 야코비안이 부정확 → 로컬 미니멈에 갇힘
```

---

## 참고 자료

- [scipy.optimize.minimize 문서](https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html)
- [scipy.optimize.least_squares 문서](https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.least_squares.html)
- [Ceres Solver](http://ceres-solver.org/)
- [g2o](https://github.com/RainerKuemmerle/g2o)
- [GTSAM](https://gtsam.org/)
