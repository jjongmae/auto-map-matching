# 카메라 파라미터 최적화 알고리즘

## 개요

차선 라벨링 데이터에 맞춰 카메라 파라미터(yaw, pitch, roll, fx, fy)를 자동으로 피팅하기 위해 사용하는 최적화 알고리즘들을 정리한 문서입니다.

## SciPy Optimize 라이브러리

본 프로젝트의 최적화 모듈은 Python의 과학 계산 라이브러리인 **SciPy**의 `optimize` 패키지를 핵심 엔진으로 사용합니다.

**SciPy**는 2001년 **Travis Oliphant**, **Pearu Peterson**, **Eric Jones** 등이 주도하여 개발한 오픈 소스 라이브러리로, NumPy를 기반으로 하여 복잡한 과학 및 공학적 계산을 위한 다양한 알고리즘을 제공합니다. 전 세계의 수많은 과학자와 엔지니어들에 의해 지속적으로 발전되어 왔으며, Python 생태계에서 사실상의 표준 과학 계산 도구로 자리 잡았습니다.

**`scipy.optimize`**는 다음과 같은 강력한 기능을 제공합니다:
- **함수 최적화**: 로컬 및 글로벌 최적화 알고리즘 제공 (`minimize`, `differential_evolution` 등)
- **최소제곱 문제 해결**: 비선형 최소제곱 문제에 특화된 솔버 제공 (`least_squares`)
- **다양한 알고리즘 지원**: 구배(Gradient) 기반 방법부터 미분 불가능한 함수를 위한 방법까지 폭넓은 알고리즘 포함

이 패키지는 안정성과 성능이 검증되어 있으며, 복잡한 수치 최적화 문제를 효율적으로 해결할 수 있도록 돕습니다. 본 프로젝트에서는 이 라이브러리를 활용하여 카메라 파라미터와 재투영된 차선 사이의 오차를 최소화합니다.

---

## 현재 구현된 알고리즘 (4가지)

### 1. Powell

**방식**: 방향 탐색 (Direction Set Method)

**쉬운 설명**:
복잡한 수식 없이 변수를 하나씩 번갈아 가며 조정해서 최적의 값을 찾는 방법입니다. 예를 들어, 카메라의 '방향'을 먼저 맞추고 그다음 '줌'을 맞추는 식으로, 한 번에 하나씩 순차적으로 조절하여 전체적인 균형을 맞춥니다.

**원리**:
- 각 파라미터 축 방향으로 순차적으로 1차원 최적화를 수행
- 한 방향으로 최적점을 찾은 후 다음 방향으로 이동
- 모든 방향을 탐색한 후, 새로운 방향 벡터를 생성하여 반복

**장점**:
- 그래디언트(기울기) 계산이 필요 없음
- 경계(bounds) 조건 지원
- 구현이 간단하고 범용적

**단점**:
- 국소 최적점(local minimum)에 빠지기 쉬움
- 파라미터 간 상관관계가 강할 때 수렴이 느림
- 고차원에서 효율이 떨어질 수 있음

**적합한 상황**:
- 파라미터 수가 적고 경계 조건이 필요할 때
- 비용 함수의 그래디언트를 계산하기 어려울 때

---

### 2. Nelder-Mead (Simplex Method)

**방식**: 심플렉스 기반 직접 탐색

**쉬운 설명**:
도형(삼각형)을 이리저리 굴리고 늘렸다 줄였다 하면서 가장 좋은 지점을 찾아가는 기하학적인 방법입니다. 복잡한 미분 계산이 필요 없어, 데이터가 매끄럽지 않거나 노이즈가 많은 상황에서도 비교적 안정적으로 답을 찾아냅니다.

**원리**:
- N차원 공간에서 (N+1)개의 꼭짓점을 가진 심플렉스(다면체)를 사용
- 심플렉스를 반사(reflection), 확장(expansion), 수축(contraction), 축소(shrink) 연산으로 변형
- 비용이 가장 높은 꼭짓점을 계속 대체하며 최적점으로 수렴

**장점**:
- 그래디언트 계산이 필요 없음
- 노이즈가 있는 비용 함수에 강건함
- 수렴이 안정적
- 저차원(10개 이하 파라미터)에서 효과적

**단점**:
- 경계 조건을 직접 지원하지 않음 (후처리로 클리핑 필요)
- 고차원에서 수렴 속도가 급격히 느려짐
- 이론적 수렴 보장이 약함

**적합한 상황**:
- 비용 함수에 노이즈가 있을 때
- 파라미터 수가 10개 이하일 때
- 그래디언트 기반 방법이 실패할 때

---

### 3. Levenberg-Marquardt (LM)

**방식**: 비선형 최소제곱 (Nonlinear Least Squares)

**쉬운 설명**:
'안전하지만 느린 방법'과 '빠르지만 불안정한 방법'을 상황에 따라 적절히 섞어 쓰는 아주 똑똑한 방식입니다. 정답에 멀리 있을 때는 조심스럽게 접근하고, 가까워지면 빠르게 정밀한 값을 찾아내어 로봇이나 카메라 분야에서 가장 많이 쓰입니다.

**원리**:
- Gauss-Newton 방법과 경사하강법의 혼합
- 야코비안(Jacobian) 행렬을 사용하여 2차 근사
- 댐핑 파라미터(λ)로 두 방법 사이를 적응적으로 전환
  - λ가 크면 → 경사하강법처럼 동작 (안정적)
  - λ가 작으면 → Gauss-Newton처럼 동작 (빠름)

**장점**:
- 비선형 최소제곱 문제에 특화
- 수렴 속도가 빠름
- 로봇 비전, 카메라 캘리브레이션의 사실상 표준
- 각 데이터 포인트의 잔차(residual)를 활용하여 효율적

**단점**:
- 비용 함수가 "잔차 제곱합" 형태여야 함
- 야코비안 계산 필요 (수치 미분 사용 시 비용 증가)
- 초기값에 민감할 수 있음
- **불연속적인(non-smooth) 비용 함수에 취약** - `min()`, `argmin()` 등 사용 시 야코비안이 부정확해짐

**적합한 상황**:
- 카메라 캘리브레이션, 포즈 추정
- 데이터 포인트별 오차를 개별적으로 계산할 수 있을 때
- **비용 함수가 파라미터에 대해 미분 가능(smooth)할 때**
- 정확도가 중요한 경우

---

### 4. Differential Evolution (DE)

**방식**: 진화 알고리즘 (Evolutionary Algorithm)

**쉬운 설명**:
여러 개의 후보 답안을 동시에 만들고, 생물의 진화(돌연변이, 교배)처럼 서로 섞어 더 좋은 답만 남기는 방식입니다. 시간은 좀 걸리지만, 엉뚱한 오답(지역 최적점)에 빠지지 않고 전체 범위에서 진짜 정답을 찾아낼 확률이 가장 높습니다.

**원리**:
- 개체군(population) 기반 최적화 알고리즘
- 각 세대마다 변이(mutation), 재조합(crossover), 선택(selection) 연산 수행
  1. **변이**: 무작위로 선택된 개체들의 차이 벡터를 이용하여 돌연변이 생성
  2. **재조합**: 원래 개체와 돌연변이를 섞어 시험 벡터 생성
  3. **선택**: 시험 벡터가 더 좋은 비용을 가지면 다음 세대로 선택
- 전역 탐색(exploration)과 지역 탐색(exploitation)의 균형을 유지

**장점**:
- **글로벌 최적화**: 로컬 미니멈 탈출 능력이 뛰어남
- 그래디언트 계산이 필요 없음
- 경계 조건 완벽 지원
- **불연속적(non-smooth)이고 노이즈가 있는 함수에 강건**
- 다봉형(multimodal) 비용 함수에 효과적
- 병렬 처리 가능 (개체군을 동시에 평가)

**단점**:
- 수렴 속도가 비교적 느림 (많은 비용 함수 평가 필요)
- 파라미터 튜닝 필요 (popsize, mutation, recombination)
- 고차원 문제에서 개체군 크기가 커져야 함
- 메모리 사용량이 많음 (개체군 전체를 저장)

**적합한 상황**:
- **로컬 미니멈이 많은 복잡한 비용 함수**
- **비용 함수가 불연속적이거나 노이즈가 있을 때**
- 글로벌 최적해를 찾는 것이 중요할 때
- 다른 알고리즘이 로컬 미니멈에 갇힐 때
- 계산 시간보다 정확도가 더 중요할 때

---

### 5. Differential Evolution (병렬 처리 버전)

**방식**: 진화 알고리즘 + 멀티프로세싱

**쉬운 설명**:
기본 DE와 동일한 원리이지만, 여러 CPU 코어를 동시에 활용하여 **10~20배 빠르게** 실행됩니다. 16개의 코어가 동시에 다른 후보 답안들을 평가하므로, 같은 품질의 결과를 훨씬 짧은 시간에 얻을 수 있습니다.

**원리**:
- 기본 DE와 동일한 알고리즘
- **멀티프로세싱**: 개체군의 비용 함수 평가를 여러 프로세스에 분산
- **Pickle 가능한 구현**: 전역 함수를 사용하여 Python의 multiprocessing 지원
- **최적화된 파라미터**:
  - `workers=16`: 16개 CPU 코어 활용
  - `maxiter=100`: 조기 수렴을 고려한 반복 횟수
  - `popsize=10`: 효율적인 개체군 크기

**장점**:
- DE의 모든 장점 유지 (글로벌 최적화, 강건성)
- **10~20배 빠른 속도** (단일 스레드 대비)
- 실시간 응용에 적합 (~3초)
- CPU 자원을 효율적으로 활용

**단점**:
- 멀티프로세싱 오버헤드 (프로세스 생성/종료)
- 메모리 사용량 증가 (각 프로세스가 데이터 복사)
- 단일 코어 시스템에서는 이점 없음

**적합한 상황**:
- **멀티코어 시스템에서 빠른 결과가 필요할 때**
- DE의 정확도를 유지하면서 속도를 개선하고 싶을 때
- 실시간 또는 대화형 응용 프로그램
- 배치 처리로 여러 이미지를 빠르게 처리할 때

**성능 비교**:
- **단일 스레드 DE**: ~30-60초
- **병렬 DE (16코어)**: ~3초
- **속도 향상**: 10~20배

---

## 5가지 알고리즘 비교

| 항목                 | Powell    | Nelder-Mead | LM                      | DE                        | **DE (병렬)**        |
| -------------------- | --------- | ----------- | ----------------------- | ------------------------- | -------------------- |
| **방식**             | 방향 탐색 | 심플렉스    | 비선형 최소제곱         | 진화 알고리즘             | 진화 + 병렬 처리     |
| **그래디언트**       | 불필요    | 불필요      | 필요 (수치 미분 가능)   | 불필요                    | 불필요               |
| **경계 지원**        | O         | X (후처리)  | O                       | O                         | O                    |
| **노이즈 강건성**    | 보통      | 강함        | 보통                    | **매우 강함**             | **매우 강함**        |
| **불연속 함수**      | 강함      | 강함        | **취약**                | **매우 강함**             | **매우 강함**        |
| **글로벌 최적화**    | 약함      | 약함        | 약함                    | **매우 강함**             | **매우 강함**        |
| **수렴 속도**        | 보통      | 느림        | 빠름 (smooth 함수일 때) | 느림                      | **매우 빠름** (병렬) |
| **정확도**           | 보통      | 보통        | 높음 (smooth 함수일 때) | **높음** (충분한 세대 시) | **높음**             |
| **실행 시간 (예상)** | ~10초     | ~15초       | ~5초                    | ~30-60초                  | **~3초** ⚡           |
| **권장 파라미터 수** | 제한 없음 | 10개 이하   | 제한 없음               | 20개 이하                 | 20개 이하            |
| **로봇 비전 사용**   | 드묾      | 가끔        | 표준 (smooth 잔차일 때) | 복잡한 문제 시            | **실시간 응용**      |

---

## 추가 알고리즘 (scipy.optimize에서 제공)

### 그래디언트 기반

| 알고리즘         | 설명                                | 경계 | 특징                              |
| ---------------- | ----------------------------------- | ---- | --------------------------------- |
| **CG**           | 켤레 기울기법 (Conjugate Gradient)  | X    | 대규모 문제에 효율적, 메모리 절약 |
| **BFGS**         | 준뉴턴법 (Quasi-Newton)             | X    | 헤시안 근사, 수렴 빠름            |
| **L-BFGS-B**     | 메모리 효율적 BFGS                  | O    | 대규모 문제, 경계 지원            |
| **TNC**          | 뉴턴 켤레 기울기 (Truncated Newton) | O    | 대규모 경계 문제에 적합           |
| **SLSQP**        | 순차 이차 계획법                    | O    | 등식/부등식 제약조건 지원         |
| **trust-constr** | 신뢰 영역 기반                      | O    | 복잡한 제약조건 지원              |

### 그래디언트 불필요

| 알고리즘   | 설명           | 경계 | 특징                         |
| ---------- | -------------- | ---- | ---------------------------- |
| **COBYLA** | 선형 근사 기반 | O    | 제약조건 지원, 노이즈에 강함 |

---

## 로봇 비전 분야에서 사용하는 전문 라이브러리

실제 프로덕션 환경에서는 scipy보다 전문 라이브러리를 더 많이 사용합니다.

### Ceres Solver (Google)

- **용도**: Bundle Adjustment, SLAM, 카메라 캘리브레이션
- **특징**: C++ 기반, 자동 미분, 희소 행렬 최적화
- **알고리즘**: LM, Dogleg, Trust Region
- **사용처**: Google Street View, Cartographer SLAM

### g2o (General Graph Optimization)

- **용도**: 그래프 기반 SLAM
- **특징**: 희소 행렬 특화, 포즈 그래프 최적화
- **알고리즘**: Gauss-Newton, LM
- **사용처**: ORB-SLAM, LSD-SLAM

### GTSAM (Georgia Tech Smoothing and Mapping)

- **용도**: Factor Graph 기반 추론
- **특징**: 확률적 추론, 증분 최적화 (iSAM2)
- **알고리즘**: Gauss-Newton, LM, iSAM2
- **사용처**: 자율주행, 드론 내비게이션

### OpenCV (solvePnP)

- **용도**: 카메라 포즈 추정
- **특징**: 간단한 API, 다양한 방법 지원
- **알고리즘**: EPnP, P3P, IPPE, LM refinement
- **사용처**: AR, 로봇 비전

---

## 알고리즘 선택 가이드

```
비용 함수가 smooth(미분 가능)한가?
├── 예 → 비용 함수가 "잔차 제곱합" 형태인가?
│        ├── 예 → Levenberg-Marquardt (LM) 권장
│        │        (가장 빠르고 정확)
│        │
│        └── 아니오 → 그래디언트 계산이 가능한가?
│                     ├── 예 → L-BFGS-B 권장
│                     │        (빠른 수렴, 경계 지원)
│                     │
│                     └── 아니오 → Powell 권장
│                                  (범용적, 경계 지원)
│
└── 아니오 (min, argmin 등 사용) → 로컬 미니멈이 많거나 글로벌 최적해가 중요한가?
                                   ├── 예 → Differential Evolution 권장
                                   │        (글로벌 최적화, 로컬 미니멈 탈출)
                                   │
                                   └── 아니오 → 노이즈가 많은가?
                                                ├── 예 → Nelder-Mead 권장
                                                │        (노이즈에 강건)
                                                │
                                                └── 아니오 → Powell 권장
                                                             (범용적, 경계 지원)
```

> **현재 프로젝트**: `min()` 기반 비용 함수 → non-smooth → **Differential Evolution, Powell, 또는 Nelder-Mead 권장**

---

## 현재 프로젝트에서의 적용

### 비용 함수 정의

```
비용 = 평균(각 라벨링 점에서 가장 가까운 투영 점까지의 거리)
잔차 = 각 라벨링 점에서 가장 가까운 투영 점까지의 거리 (LM용)
```

### 비용 함수의 특성

**중요**: 현재 비용 함수는 `np.min(distances, axis=1)`을 사용하여 "가장 가까운 점"을 찾습니다.
이 `min()` 연산은 **불연속점(non-smooth)**을 만듭니다:
- 파라미터가 조금 바뀌면 "가장 가까운 점"이 갑자기 다른 점으로 바뀔 수 있음
- 이 지점에서 야코비안(미분)이 불연속이 되어 LM 알고리즘의 방향 탐색이 부정확해짐
- 결과적으로 LM이 로컬 미니멈에 쉽게 갇히고 조기 종료됨

### 최적화 대상 파라미터 (5개)

| 파라미터 | 설명          | 탐색 범위 |
| -------- | ------------- | --------- |
| yaw      | 수평 회전     | ±10도     |
| pitch    | 수직 회전     | ±10도     |
| roll     | 축 회전       | ±10도     |
| fx       | 수평 초점거리 | ±20%      |
| fy       | 수직 초점거리 | ±20%      |

### 권장 사용 순서

> **주의**: 현재 프로젝트의 비용 함수는 `min()` 기반으로 불연속적이므로,
> 그래디언트 기반인 LM보다 derivative-free 방법이 더 적합합니다.

1. **DE (병렬)**: **가장 먼저 시도 권장** ⚡ (빠르고 정확, 글로벌 최적화)
2. **Powell**: 빠른 로컬 최적화가 필요할 때
3. **Differential Evolution (단일)**: 시간이 충분하고 최고 정확도가 필요할 때
4. **Nelder-Mead**: 노이즈가 의심되거나 다른 방법이 실패할 때
5. **LM**: 참고용 (이론적으로는 좋지만 현재 비용 함수와 궁합이 맞지 않음)

**알고리즘별 사용 시나리오**:
- **일반적인 경우**: **DE (병렬)** 권장 (~3초, 글로벌 최적해)
- **빠른 결과가 필요**: Powell (~10초)
- **최고 정확도 + 시간 충분**: DE 단일 스레드 (~30-60초)
- **다른 알고리즘이 실패**: DE (병렬 또는 단일)로 재시도 (로컬 미니멈 탈출)
- **실시간 응용**: DE (병렬) (~3초로 충분히 빠름)

### LM이 잘 작동하지 않는 이유

```
[일반적인 카메라 캘리브레이션]
- 체커보드 코너 검출 → 대응점이 명확히 1:1 매칭됨
- 잔차 = 검출점과 투영점의 거리 → smooth 함수
- LM이 최적

[현재 프로젝트]
- 라벨링 점 → 가장 가까운 투영 차선점 매칭 (min 연산)
- 잔차 = 라벨링 점에서 가장 가까운 점까지의 거리 → non-smooth 함수
- LM의 야코비안이 부정확 → 로컬 미니멈에 갇힘
```

---

## 참고 자료

- [scipy.optimize.minimize 문서](https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html)
- [scipy.optimize.least_squares 문서](https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.least_squares.html)
- [Ceres Solver](http://ceres-solver.org/)
- [g2o](https://github.com/RainerKuemmerle/g2o)
- [GTSAM](https://gtsam.org/)
